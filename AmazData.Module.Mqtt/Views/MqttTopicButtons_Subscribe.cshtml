@using AmazData.Module.Mqtt.Models
@using AmazData.Module.Mqtt.Services
@using System.Linq

@model AmazData.Module.Mqtt.Models.MqttBrokerButtonsViewModel

@inject IContentManager ContentManager
@inject IMqttSubscriptionManager SubscriptionManager

@{
    if (Model.ContentItem == null)
    {
        return;
    }

    // We need the latest version to get the relationships.
    var contentItem = await ContentManager.GetAsync(Model.ContentItem.ContentItemId, VersionOptions.Latest);
    if (contentItem == null)
    {
        return;
    }

    var topicPart = contentItem.As<TopicPart>();
    var topicPattern = topicPart?.TopicPattern?.Text;
    var brokerId = topicPart?.Broker?.ContentItemIds?.FirstOrDefault();

    if (string.IsNullOrEmpty(topicPattern) || string.IsNullOrEmpty(brokerId))
    {
        // Don't render a button if the topic or its broker association is not fully configured.
        <span class="text-muted small">未配置</span>
        return;
    }

    var subscriptions = await SubscriptionManager.ListSubscriptionsAsync(brokerId);
    var isSubscribed = subscriptions.Contains(topicPattern);

    var buttonText = isSubscribed ? "取消订阅" : "订阅";
    var buttonClass = isSubscribed ? "btn-warning" : "btn-success";
    var actionName = isSubscribed ? "Unsubscribe" : "Subscribe";
}

<a asp-area="AmazData.Module.Mqtt"
   asp-controller="MqttTopic"
   asp-action="@actionName"
   asp-route-topicId="@Model.ContentItem.ContentItemId"
   class="btn btn-sm @buttonClass">@buttonText</a>





  @*   Code Review 报告: AmazData.Module.Mqtt (Views & Drivers)

  总体评价: 功能上，UI 组件基本可以工作。但从架构和最佳实践上看，这部分代码的实现质量参差不齐，存在一些严重的设计问题，特别是业务逻辑泄露到了视图（View）中。

  ---

  1. 紧急问题 (Critical)

   * `MqttTopicButtons_Subscribe.cshtml` 视图包含了业务逻辑 (Architectural Flaw)
       * 问题: 这个视图文件 (.cshtml) 内部通过 @inject 注入了 IContentManager 和 IMqttSubscriptionManager，并包含了获取数据、执行判断、决定订阅状态等一系列复杂的后端逻辑。这是一个严重的架构错误。在 Orchard
         Core (以及通用的 MVC 模式) 中，视图应该保持“哑”（Dumb），只负责展示模型（Model）提供给它的数据。
       * 危害:
           1. 难以维护: 后端逻辑散落在视图文件中，非常难找。
           2. 违反“单一职责”原则: 视图承担了它不该承担的责任。
           3. 性能问题: 在视图中注入并调用服务，会使页面的渲染过程变得复杂和缓慢。
           4. 难以测试: 无法对视图中的逻辑进行单元测试。
       * 建议:
           1. 重构 `MqttTopicButtonsDisplayDriver`: 将 MqttTopicButtons_Subscribe.cshtml 中所有的 C# 逻辑代码全部移动到这个 Driver 的 Display 或 DisplayAsync 方法中。
           2. 创建专用 ViewModel: 创建一个 MqttTopicButtonsViewModel，包含 bool IsSubscribed 属性。
           3. 由 Driver 准备数据: Driver 负责调用 Service、获取状态，并填充 ViewModel。
           4. 简化 View: MqttTopicButtons_Subscribe.cshtml 应该被清理得像 MqttBrokerButtons.Start.cshtml 一样干净，只包含最简单的 if/else 判断和 HTML 标签。

  2. 重要问题 (High Priority)

   * 发现潜在的死代码或未完成的功能 (Dead/Unused Code)
       * 问题: 代码库中存在几个看似无用的文件：
           1. AmazDataMqttUserButtonDisplayDriver.cs: 它为一个名为 AmazDataMqttUserButton_SummaryAdmin 的 Shape 注册了 Driver，但项目中不存在对应的 .cshtml 视图文件。
           2. ContentsButtonRun_SummaryAdmin.cshtml 和 MqttBroker/ConnectBroker.cshtml: 这两个视图似乎也未被任何活动的 Driver 或 Controller 调用。ConnectBroker Action 是一个重定向操作，并不会返回一个 View。
       * 建议: 请团队确认这些文件是否还在使用。如果确认是废弃的开发遗留物，请立即删除，以保持代码库的整洁，避免给新成员带来困惑。

  3. 建议与优化 (Suggestions & Refinements)

   * 保持一致性是王道 (Consistency)
       * 做得好的地方: MqttBrokerButtonsDisplayDriver.cs 和 MqttBrokerButtons.Start.cshtml 的实现方式是一个完美的范例。Driver 负责准备数据，View 负责简单地渲染。
       * 建议: 将“Broker 按钮”的实现模式作为你们团队内部的“黄金标准”。所有类似的“在列表项上显示动态按钮”的功能，都应该遵循这个模式来开发。

  ---

  总结与后续步骤:

  当前最关键的任务，是彻底重构 `MqttTopicButtons` 的实现，将逻辑从 View 迁移到 Driver。这是提升这个模块架构健康度的核心。

  完成这项重构，并清理掉不再使用的文件后，这个模块的整体质量将会得到一个质的飞跃。

  到此，我们已经完整地 Review 了 Services, Controllers, Models, Migrations, Views, Drivers。你对整个模块的代码质量已经有了全面的了解。如果你希望我 review 模块的入口和配置（如 Startup.cs 和
  Manifest.cs），请随时提出。 *@